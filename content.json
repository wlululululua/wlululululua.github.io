{"pages":[{"title":"","text":"关于我本科软件工程，2019年毕业，经历了考研、考研二战、多次考公考编均未成功… 2021年11月1日起，重新拾起代码，想在互联网这条路上坚定的走下去。 关于这个博客记录自己的学习过程，可能是学习笔记，也可能是学习中遇到的一些问题，总之，记录一切我想要记录的东西，方便回顾。","link":"/about/index.html"}],"posts":[{"title":"关于JS中的函数","text":"关于JS中的函数的基础知识testtest1","link":"/2022/01/21/all-you-should-know-about-js-functions/"},{"title":"执行上下文(Execution Context)","text":"写在前面我很早就接触到了JS（从大学开始，但是当时学的特别浅，特别的表面，也可以说啥重点都没学会…）我总是做不到真正的去理解JS，经常性的对于JS运行之后的一些结果感到十分困惑，以致于把这种学不会的原因都归咎于JS这门语言本身…但是最近俺在youtube上观看了很多优质的课程，发现真正弄懂JS是如何运行的之后，学习JS开始变得有趣起来！所以，俺决定去真正的搞懂俺以前畏惧的一些东西，不再停留于表面，理解并且把它们记录下来。知识学会了就是自己的。深入学习JS先从理解Execution Context开始吧。 什么是执行上下文 “Everything in JavaScript happens inside an Execution Context.” Two Components我们所有的JS代码其实都是在执行上下文中运行的，可以把执行上下文理解为一个大盒子。这个大盒子由两个部分组成： Memory componentMemory component有一个别名叫做Variable Environment，这个别名可能更好理解一些，就是变量存放的一个环境。这个变量环境包含变量和函数的键值对。 Code componentCode component同样有一个别名，叫做Thread of Execution，即执行线程。所有的JS代码都是在这个地方被执行的。 “JavaScript is a synchronous single-threaded language.” JS是一门同步的单线程语言。 先把线程理解为银行的一个窗口吧，所有来窗口办理业务的人可以理解为JS中等待执行的一行语句。意思就是说，只有一个窗口可以用来执行JS代码，所有的JS代码都只能在这个窗口排队等待被执行，这就是单线程的意思。同步就是按照顺序来执行。即只有我前面的人办理好他的业务之后，才能轮到我办理业务，如果他的业务没办理完，我只能一直排队。 Two Phase执行上下文中一共有两个阶段： Creation Phase创建阶段，即构建变量和函数的阶段，为变量和函数分配内存。这个阶段就是构建Variable Environment里的键值对的内容。提升(hoisting)就发生在这个阶段。 Execution Phase执行阶段，每一行JS语句的执行都是在执行阶段进行处理的。JS引擎一行接一行的执行JS语句 何时创建执行上下文上面说了，我们所有的JS代码都是在执行上下文中运行的，即只要执行一个JS文件，相应的一个执行上下文就会被创建，哪怕是一个空白的，没有任何语句的.js文件。这里创建的执行上下文叫做全局执行上下文(Global Execution Context)。除了全局执行上下文外，还有函数执行上下文(Function Execution Context)，即当我们调用一个函数时，执行上下文也会被创建，这时的执行上下文为函数执行上下文。 Global Execution Context全局执行上下文被创建出来后，也同时给我们提供了两个东西： 全局对象(global object) this关键字 这两个东西都是跟随全局执行上下文一起被创建的，即有了全局执行上下文，它们也随之诞生。 全局对象(global object)在浏览器中，全局执行上下文提供给我们的全局对象是window对象。在Node.js中，提供的全局对象是global对象。不同的JS运行环境，全局对象是不同的。 这就是为什么在浏览器中我们可以使用document.getElementById()的原因，因为document是window对象的一个属性，即我们其实使用的是window.document.getElementById()。 但是为什么不加window也可以呢？因为如果我们不再它的前面放任何东西，它就会假设自己在全局空间中，所以不加window也是可以的。 this关键字全局执行上下文中的this关键字其实就是指向全局对象。在浏览器中，即：this === window为true。在Node.js中，即：this === global为true。 Function Execution Context当我们调用一个函数时，函数执行上下文就被创建了。函数执行上下文被创建出来后，同样给我们提供了两个东西： arguments对象 this关键字 arguments对象arguments对象是一个类数组对象，即{length: 0}（没有参数传递时的arguments对象）。arguments对应于传递给函数的参数的类数组对象。 this关键字函数执行上下文中的this关键字指向函数在哪被调用，即谁调用了函数。这个值的指向是动态的可变的，完全取决于函数如何被调用。 何时释放执行上下文只要执行JS文件，哪怕是一个空的文件，全局执行上下文都会被创建。只要调用函数，函数执行上下文也会被创建。 那执行上下文何时消失呢？当函数调用结束后，该函数执行上下文就会消失。当JS文件执行完成后，全局执行上下文也会消失。 “Call stack manintains the order of execution of execution context” JS提供了一个叫做调用栈(Call Stack)的数据结构去跟踪所有的执行上下文，只要函数被调用，产生了执行上下文，就会入栈，当函数调用结束后，该执行上下文就会出栈，表示函数调用完成。当然，栈底是全局执行上下文。 学习资料 Akshay Saini Namaste JavaScript codeWithSimran Execution context | Front-end interview series","link":"/2021/12/29/execution-context/"},{"title":"队列的两种实现方式","text":"简介队列是一种先进先出的数据结构，即First In First Out(FIFO)。 队列有两个基本操作： 入队(enqueue) 出队(dequeue) 队列同样限制了操作方向，入队操作只能在队尾(back)进行，出队操作只能在队头(front)进行。 队列的数组实现方式JS没有内置的队列数据结构，但是JS的数组提供了两个方法push和shift可以用来模拟队列操作。 Array.prototype.push()：将一个或多个元素添加到数组的末尾。Array.prototype.shift()：删除数组的第一个元素。 push方法在数组末尾进行操作，这里的数组末尾就是队列的队尾(back)，实现enqueue。shift方法操作数组第一个元素，这里的数组第一个元素就是队列的队头(front)，实现dequeue。 123456const queue = [];queue.push('a');queue.push('b');console.log(queue); //['a', 'b']queue.shift();//'a'console.log(queue); //['b'] 时间复杂度： push： O(1) shift： O(n) n为数组长度。因为数组删除第一个元素之后，剩余所有元素都要向前一步进行补位，要遍历剩余所有元素。 队列的链表实现方式使用链表实现队列，就是创建一个具有头尾指针的单链表。头指针head就相当于队列的front，尾指针tail永远指向链表中的最后一个元素，就相当于队列的back。enqueue操作就是addAtTail。dequeue操作就是deleteAtHead。 注意：当队列中只有一个元素时，头尾指针指向是相同的。所以当进行dequeue操作时，当只有一个元素时需要对back指针也进行重置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class QueueNode { constructor(val) { this.val = val; this.next = null; }}class Queue { constructor() { this.front = null; this.back = null; this.size = 0; } enqueue(val) { const newNode = new QueueNode(val); if(this.size === 0) { this.front = newNode; this.back = newNode; } else { this.back.next = newNode; this.back = newNode; } this.size++; } dequeue() { if(this.size === 0) return null; const removeNode = this.front; if(this.size === 1) { this.back = null; } this.front = this.front.next; this.size--; return removeNode.val; }}const queue = new Queue();queue.enqueue('a');queue.enqueue('b');console.log(queue.front.val);//'a'console.log(queue.back.val);//'b'console.log(queue.dequeue()); // 'a'console.log(queue.size);//1console.log(queue.dequeue());// 'b'console.log(queue.dequeue());// nullconsole.log(queue.front === queue.back);// true 时间复杂度： enqueue：O(1) dequeue：O(1) 对比数组的实现方式，用链表实现队列要更加高效。 学习资料 Alvin Introduction to the Queue Data Structure Array.prototype.push Array.prototype.shift","link":"/2022/01/01/implementation-of-queue/"},{"title":"栈的两种实现方式","text":"简介栈是一种后进先出的数据结构，即Last In First Out(LIFO)。 栈有两个基本操作： 入栈(push) 出栈(pop) 栈被限制了操作方向，只能在栈顶(top)进行操作，出栈和入栈都必须在栈顶进行。 栈的数组实现方式JS没有内置的栈数据结构，但是JS的数组提供了两个方法push和pop来实现栈。 Array.prototype.push()：将一个或多个元素添加到数组的末尾。Array.prototype.pop()：删除数组最后一个元素。 push和pop方法都是在数组末尾进行操作，这里的数组末尾就是栈顶，栈的top位置。 123456const stack = [];stack.push('a');stack.push('b')console.log(stack); //['a', 'b']stack.pop();//'b'console.log(stack); //['a'] 时间复杂度： push：O(1) pop：O(1) 栈的链表实现方式使用链表实现栈，链表的head就相当于栈的top。push操作就相当于addAtHead。pop操作就相当于deleteAtHead。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class StackNode { constructor(val) { this.val = val; this.next = null; }}class Stack { constructor() { this.top = null; this.size = 0; } push(val) { const pushedNode = new StackNode(val); if(this.size === 0) { this.top = pushedNode; } else { pushedNode.next = this.top; this.top = pushedNode; } this.size++; } pop() { if(this.size === 0) return null; const popedNode = this.top; this.top = this.top.next; this.size--; return popedNode.val; } getTop() { return this.top.val; }}const stack = new Stack();stack.push('a');stack.push('b');console.log(stack.size);// 2console.log(stack.getTop());//'b'stack.pop();console.log(stack.size);//1console.log(stack.getTop());//'a' 时间复杂度： push：O(1) pop：O(1) 学习资料 Alvin Introduction to the Stack Data Structure Array.prototype.push Array.prototype.pop","link":"/2022/01/01/implementation-of-stack/"}],"tags":[{"name":"js","slug":"js","link":"/tags/js/"},{"name":"queue","slug":"queue","link":"/tags/queue/"},{"name":"stack","slug":"stack","link":"/tags/stack/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"基础知识","slug":"JavaScript/基础知识","link":"/categories/JavaScript/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"必须知道的东东","slug":"JavaScript/必须知道的东东","link":"/categories/JavaScript/%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%9C%E4%B8%9C/"}]}