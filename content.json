{"pages":[{"title":"","text":"关于我本科软件工程，2019年毕业，经历了考研、考研二战、多次考公考编均未成功… 2021年11月1日起，重新拾起代码，想在互联网这条路上坚定的走下去。 关于这个博客记录自己的学习过程，可能是学习笔记，也可能是学习中遇到的一些问题，总之，记录一切我想要记录的东西，方便回顾。","link":"/about/index.html"}],"posts":[{"title":"执行上下文(Execution Context)","text":"写在前面我很早就接触到了JS（从大学开始，但是当时学的特别浅，特别的表面，也可以说啥重点都没学会…）我总是做不到真正的去理解JS，经常性的对于JS运行之后的一些结果感到十分困惑，以致于把这种学不会的原因都归咎于JS这门语言本身…但是最近俺在youtube上观看了很多优质的课程，发现真正弄懂JS是如何运行的之后，学习JS开始变得有趣起来！所以，俺决定去真正的搞懂俺以前畏惧的一些东西，不再停留于表面，理解并且把它们记录下来。知识学会了就是自己的。深入学习JS先从理解Execution Context开始吧。 什么是执行上下文 “Everything in JavaScript happens inside an Execution Context.” Two Components我们所有的JS代码其实都是在执行上下文中运行的，可以把执行上下文理解为一个大盒子。这个大盒子由两个部分组成： Memory componentMemory component有一个别名叫做Variable Environment，这个别名可能更好理解一些，就是变量存放的一个环境。这个变量环境包含变量和函数的键值对。 Code componentCode component同样有一个别名，叫做Thread of Execution，即执行线程。所有的JS代码都是在这个地方被执行的。 “JavaScript is a synchronous single-threaded language.” JS是一门同步的单线程语言。 先把线程理解为银行的一个窗口吧，所有来窗口办理业务的人可以理解为JS中等待执行的一行语句。意思就是说，只有一个窗口可以用来执行JS代码，所有的JS代码都只能在这个窗口排队等待被执行，这就是单线程的意思。同步就是按照顺序来执行。即只有我前面的人办理好他的业务之后，才能轮到我办理业务，如果他的业务没办理完，我只能一直排队。 Two Phase执行上下文中一共有两个阶段： Creation Phase创建阶段，即构建变量和函数的阶段，为变量和函数分配内存。这个阶段就是构建Variable Environment里的键值对的内容。提升(hoisting)就发生在这个阶段。 Execution Phase执行阶段，每一行JS语句的执行都是在执行阶段进行处理的。JS引擎一行接一行的执行JS语句 何时创建执行上下文上面说了，我们所有的JS代码都是在执行上下文中运行的，即只要执行一个JS文件，相应的一个执行上下文就会被创建，哪怕是一个空白的，没有任何语句的.js文件。这里创建的执行上下文叫做全局执行上下文(Global Execution Context)。除了全局执行上下文外，还有函数执行上下文(Function Execution Context)，即当我们调用一个函数时，执行上下文也会被创建，这时的执行上下文为函数执行上下文。 Global Execution Context全局执行上下文被创建出来后，也同时给我们提供了两个东西： 全局对象(global object) this关键字 这两个东西都是跟随全局执行上下文一起被创建的，即有了全局执行上下文，它们也随之诞生。 全局对象(global object)在浏览器中，全局执行上下文提供给我们的全局对象是window对象。在Node.js中，提供的全局对象是global对象。不同的JS运行环境，全局对象是不同的。 这就是为什么在浏览器中我们可以使用document.getElementById()的原因，因为document是window对象的一个属性，即我们其实使用的是window.document.getElementById()。 但是为什么不加window也可以呢？因为如果我们不再它的前面放任何东西，它就会假设自己在全局空间中，所以不加window也是可以的。 this关键字全局执行上下文中的this关键字其实就是指向全局对象。在浏览器中，即：this === window为true。在Node.js中，即：this === global为true。 Function Execution Context当我们调用一个函数时，函数执行上下文就被创建了。函数执行上下文被创建出来后，同样给我们提供了两个东西： arguments对象 this关键字 arguments对象arguments对象是一个类数组对象，即{length: 0}（没有参数传递时的arguments对象）。arguments对应于传递给函数的参数的类数组对象。 this关键字函数执行上下文中的this关键字指向函数在哪被调用，即谁调用了函数。这个值的指向是动态的可变的，完全取决于函数如何被调用。 何时释放执行上下文只要执行JS文件，哪怕是一个空的文件，全局执行上下文都会被创建。只要调用函数，函数执行上下文也会被创建。 那执行上下文何时消失呢？当函数调用结束后，该函数执行上下文就会消失。当JS文件执行完成后，全局执行上下文也会消失。 “Call stack manintains the order of execution of execution context” JS提供了一个叫做调用栈(Call Stack)的数据结构去跟踪所有的执行上下文，只要函数被调用，产生了执行上下文，就会入栈，当函数调用结束后，该执行上下文就会出栈，表示函数调用完成。当然，栈底是全局执行上下文。 学习资料 Akshay Saini Namaste JavaScript codeWithSimran Execution context | Front-end interview series","link":"/2021/12/29/execution-context/"}],"tags":[{"name":"js","slug":"js","link":"/tags/js/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"必须知道的东东","slug":"JavaScript/必须知道的东东","link":"/categories/JavaScript/%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%9C%E4%B8%9C/"}]}